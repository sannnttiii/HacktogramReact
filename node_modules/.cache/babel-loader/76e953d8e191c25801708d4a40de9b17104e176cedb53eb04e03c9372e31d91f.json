{"ast":null,"code":"'use client';\n\n// src/use-editable.ts\nimport { useFocusOnPointerDown } from \"@chakra-ui/react-use-focus-on-pointer-down\";\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\";\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\";\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\";\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\";\nimport { useCallbackRef } from \"@chakra-ui/react-use-callback-ref\";\nimport { ariaAttr, callAllHandlers } from \"@chakra-ui/shared-utils\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nfunction contains(parent, child) {\n  if (!parent) return false;\n  return parent === child || parent.contains(child);\n}\nfunction useEditable() {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    onChange: onChangeProp,\n    onCancel: onCancelProp,\n    onSubmit: onSubmitProp,\n    onBlur: onBlurProp,\n    value: valueProp,\n    isDisabled,\n    defaultValue,\n    startWithEditView,\n    isPreviewFocusable = true,\n    submitOnBlur = true,\n    selectAllOnFocus = true,\n    placeholder,\n    onEdit: onEditCallback,\n    finalFocusRef,\n    ...htmlProps\n  } = props;\n  const onEditProp = useCallbackRef(onEditCallback);\n  const defaultIsEditing = Boolean(startWithEditView && !isDisabled);\n  const [isEditing, setIsEditing] = useState(defaultIsEditing);\n  const [value, setValue] = useControllableState({\n    defaultValue: defaultValue || \"\",\n    value: valueProp,\n    onChange: onChangeProp\n  });\n  const [prevValue, setPrevValue] = useState(value);\n  const inputRef = useRef(null);\n  const previewRef = useRef(null);\n  const editButtonRef = useRef(null);\n  const cancelButtonRef = useRef(null);\n  const submitButtonRef = useRef(null);\n  useFocusOnPointerDown({\n    ref: inputRef,\n    enabled: isEditing,\n    elements: [cancelButtonRef, submitButtonRef]\n  });\n  const isInteractive = !isEditing && !isDisabled;\n  useSafeLayoutEffect(() => {\n    var _a, _b;\n    if (isEditing) {\n      (_a = inputRef.current) == null ? void 0 : _a.focus();\n      if (selectAllOnFocus) (_b = inputRef.current) == null ? void 0 : _b.select();\n    }\n  }, []);\n  useUpdateEffect(() => {\n    var _a, _b, _c, _d;\n    if (!isEditing) {\n      if (finalFocusRef) {\n        (_a = finalFocusRef.current) == null ? void 0 : _a.focus();\n      } else {\n        (_b = editButtonRef.current) == null ? void 0 : _b.focus();\n      }\n      return;\n    }\n    (_c = inputRef.current) == null ? void 0 : _c.focus();\n    if (selectAllOnFocus) {\n      (_d = inputRef.current) == null ? void 0 : _d.select();\n    }\n    onEditProp == null ? void 0 : onEditProp();\n  }, [isEditing, onEditProp, selectAllOnFocus]);\n  const onEdit = useCallback(() => {\n    if (isInteractive) {\n      setIsEditing(true);\n    }\n  }, [isInteractive]);\n  const onUpdatePrevValue = useCallback(() => {\n    setPrevValue(value);\n  }, [value]);\n  const onCancel = useCallback(() => {\n    setIsEditing(false);\n    setValue(prevValue);\n    onCancelProp == null ? void 0 : onCancelProp(prevValue);\n    onBlurProp == null ? void 0 : onBlurProp(prevValue);\n  }, [onCancelProp, onBlurProp, setValue, prevValue]);\n  const onSubmit = useCallback(() => {\n    setIsEditing(false);\n    setPrevValue(value);\n    onSubmitProp == null ? void 0 : onSubmitProp(value);\n    onBlurProp == null ? void 0 : onBlurProp(prevValue);\n  }, [value, onSubmitProp, onBlurProp, prevValue]);\n  useEffect(() => {\n    if (isEditing) return;\n    const inputEl = inputRef.current;\n    if ((inputEl == null ? void 0 : inputEl.ownerDocument.activeElement) === inputEl) {\n      inputEl == null ? void 0 : inputEl.blur();\n    }\n  }, [isEditing]);\n  const onChange = useCallback(event => {\n    setValue(event.currentTarget.value);\n  }, [setValue]);\n  const onKeyDown = useCallback(event => {\n    const eventKey = event.key;\n    const keyMap = {\n      Escape: onCancel,\n      Enter: event2 => {\n        if (!event2.shiftKey && !event2.metaKey) {\n          onSubmit();\n        }\n      }\n    };\n    const action = keyMap[eventKey];\n    if (action) {\n      event.preventDefault();\n      action(event);\n    }\n  }, [onCancel, onSubmit]);\n  const onKeyDownWithoutSubmit = useCallback(event => {\n    const eventKey = event.key;\n    const keyMap = {\n      Escape: onCancel\n    };\n    const action = keyMap[eventKey];\n    if (action) {\n      event.preventDefault();\n      action(event);\n    }\n  }, [onCancel]);\n  const isValueEmpty = value.length === 0;\n  const onBlur = useCallback(event => {\n    var _a;\n    if (!isEditing) return;\n    const doc = event.currentTarget.ownerDocument;\n    const relatedTarget = (_a = event.relatedTarget) != null ? _a : doc.activeElement;\n    const targetIsCancel = contains(cancelButtonRef.current, relatedTarget);\n    const targetIsSubmit = contains(submitButtonRef.current, relatedTarget);\n    const isValidBlur = !targetIsCancel && !targetIsSubmit;\n    if (isValidBlur) {\n      if (submitOnBlur) {\n        onSubmit();\n      } else {\n        onCancel();\n      }\n    }\n  }, [submitOnBlur, onSubmit, onCancel, isEditing]);\n  const getPreviewProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const tabIndex = isInteractive && isPreviewFocusable ? 0 : void 0;\n    return {\n      ...props2,\n      ref: mergeRefs(ref, previewRef),\n      children: isValueEmpty ? placeholder : value,\n      hidden: isEditing,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      tabIndex,\n      onFocus: callAllHandlers(props2.onFocus, onEdit, onUpdatePrevValue)\n    };\n  }, [isDisabled, isEditing, isInteractive, isPreviewFocusable, isValueEmpty, onEdit, onUpdatePrevValue, placeholder, value]);\n  const getInputProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return {\n      ...props2,\n      hidden: !isEditing,\n      placeholder,\n      ref: mergeRefs(ref, inputRef),\n      disabled: isDisabled,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      value,\n      onBlur: callAllHandlers(props2.onBlur, onBlur),\n      onChange: callAllHandlers(props2.onChange, onChange),\n      onKeyDown: callAllHandlers(props2.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props2.onFocus, onUpdatePrevValue)\n    };\n  }, [isDisabled, isEditing, onBlur, onChange, onKeyDown, onUpdatePrevValue, placeholder, value]);\n  const getTextareaProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return {\n      ...props2,\n      hidden: !isEditing,\n      placeholder,\n      ref: mergeRefs(ref, inputRef),\n      disabled: isDisabled,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      value,\n      onBlur: callAllHandlers(props2.onBlur, onBlur),\n      onChange: callAllHandlers(props2.onChange, onChange),\n      onKeyDown: callAllHandlers(props2.onKeyDown, onKeyDownWithoutSubmit),\n      onFocus: callAllHandlers(props2.onFocus, onUpdatePrevValue)\n    };\n  }, [isDisabled, isEditing, onBlur, onChange, onKeyDownWithoutSubmit, onUpdatePrevValue, placeholder, value]);\n  const getEditButtonProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return {\n      \"aria-label\": \"Edit\",\n      ...props2,\n      type: \"button\",\n      onClick: callAllHandlers(props2.onClick, onEdit),\n      ref: mergeRefs(ref, editButtonRef),\n      disabled: isDisabled\n    };\n  }, [onEdit, isDisabled]);\n  const getSubmitButtonProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return {\n      ...props2,\n      \"aria-label\": \"Submit\",\n      ref: mergeRefs(submitButtonRef, ref),\n      type: \"button\",\n      onClick: callAllHandlers(props2.onClick, onSubmit),\n      disabled: isDisabled\n    };\n  }, [onSubmit, isDisabled]);\n  const getCancelButtonProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return {\n      \"aria-label\": \"Cancel\",\n      id: \"cancel\",\n      ...props2,\n      ref: mergeRefs(cancelButtonRef, ref),\n      type: \"button\",\n      onClick: callAllHandlers(props2.onClick, onCancel),\n      disabled: isDisabled\n    };\n  }, [onCancel, isDisabled]);\n  return {\n    isEditing,\n    isDisabled,\n    isValueEmpty,\n    value,\n    onEdit,\n    onCancel,\n    onSubmit,\n    getPreviewProps,\n    getInputProps,\n    getTextareaProps,\n    getEditButtonProps,\n    getSubmitButtonProps,\n    getCancelButtonProps,\n    htmlProps\n  };\n}\nexport { useEditable };","map":{"version":3,"mappings":"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","names":["useFocusOnPointerDown","useSafeLayoutEffect","useUpdateEffect","useControllableState","mergeRefs","useCallbackRef","ariaAttr","callAllHandlers","useCallback","useEffect","useRef","useState","contains","parent","child","useEditable","props","onChange","onChangeProp","onCancel","onCancelProp","onSubmit","onSubmitProp","onBlur","onBlurProp","value","valueProp","isDisabled","defaultValue","startWithEditView","isPreviewFocusable","submitOnBlur","selectAllOnFocus","placeholder","onEdit","onEditCallback","finalFocusRef","htmlProps","onEditProp","defaultIsEditing","Boolean","isEditing","setIsEditing","setValue","prevValue","setPrevValue","inputRef","previewRef","editButtonRef","cancelButtonRef","submitButtonRef","ref","enabled","elements","isInteractive","current","focus","select","onUpdatePrevValue","inputEl","ownerDocument","activeElement","blur","event","currentTarget","onKeyDown","eventKey","key","keyMap","Escape","Enter","shiftKey","metaKey","action","preventDefault","onKeyDownWithoutSubmit","isValueEmpty","length","doc","relatedTarget","_a","targetIsCancel","targetIsSubmit","isValidBlur","getPreviewProps","tabIndex","children","hidden","onFocus","getInputProps","disabled","getTextareaProps","getEditButtonProps","type","onClick","getSubmitButtonProps","getCancelButtonProps","id"],"sources":["/Users/santitri1205/Documents/SkillAcademy/BATCH2/react-final-project-hacktogram-v1/node_modules/@chakra-ui/editable/src/use-editable.ts"],"sourcesContent":["import { useFocusOnPointerDown } from \"@chakra-ui/react-use-focus-on-pointer-down\"\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\"\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\"\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\"\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\"\nimport { useCallbackRef } from \"@chakra-ui/react-use-callback-ref\"\nimport { ariaAttr, callAllHandlers } from \"@chakra-ui/shared-utils\"\nimport { PropGetter } from \"@chakra-ui/react-types\"\nimport { useCallback, useEffect, useRef, useState, RefObject } from \"react\"\n\ninterface FocusableElement {\n  focus(options?: FocusOptions): void\n}\n\nexport interface UseEditableProps {\n  /**\n   * The value of the Editable in both edit & preview mode\n   */\n  value?: string\n  /**\n   * The initial value of the Editable in both edit & preview mode\n   */\n  defaultValue?: string\n  /**\n   * If `true`, the Editable will be disabled.\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the Editable will start with edit mode by default.\n   */\n  startWithEditView?: boolean\n  /**\n   * If `true`, the read only view, has a `tabIndex` set to `0`\n   * so it can receive focus via the keyboard or click.\n   * @default true\n   */\n  isPreviewFocusable?: boolean\n  /**\n   * If `true`, it'll update the value onBlur and turn off the edit mode.\n   * @default true\n   */\n  submitOnBlur?: boolean\n  /**\n   * Callback invoked when user changes input.\n   */\n  onChange?: (nextValue: string) => void\n  /**\n   * Callback invoked when user cancels input with the `Esc` key.\n   * It provides the last confirmed value as argument.\n   */\n  onCancel?: (previousValue: string) => void\n  /**\n   * Callback invoked when user confirms value with `enter` key or by blurring input.\n   */\n  onSubmit?: (nextValue: string) => void\n  /**\n   * Callback invoked once the user enters edit mode.\n   */\n  onEdit?: () => void\n  /**\n   * Callback invoked when the user either submits or cancels.\n   * It provides the last confirmed value as argument.\n   */\n  onBlur?: (nextValue: string) => void\n  /**\n   * If `true`, the input's text will be highlighted on focus.\n   * @default true\n   */\n  selectAllOnFocus?: boolean\n  /**\n   * The placeholder text when the value is empty.\n   */\n  placeholder?: string\n  /**\n   * The `ref` of element to receive focus when the modal closes.\n   */\n  finalFocusRef?: RefObject<FocusableElement>\n}\n\nfunction contains(parent: HTMLElement | null, child: HTMLElement) {\n  if (!parent) return false\n  return parent === child || parent.contains(child)\n}\n\n/**\n * React hook for managing the inline renaming of some text.\n *\n * @see Docs https://chakra-ui.com/editable\n */\nexport function useEditable(props: UseEditableProps = {}) {\n  const {\n    onChange: onChangeProp,\n    onCancel: onCancelProp,\n    onSubmit: onSubmitProp,\n    onBlur: onBlurProp,\n    value: valueProp,\n    isDisabled,\n    defaultValue,\n    startWithEditView,\n    isPreviewFocusable = true,\n    submitOnBlur = true,\n    selectAllOnFocus = true,\n    placeholder,\n    onEdit: onEditCallback,\n    finalFocusRef,\n    ...htmlProps\n  } = props\n\n  const onEditProp = useCallbackRef(onEditCallback)\n\n  const defaultIsEditing = Boolean(startWithEditView && !isDisabled)\n\n  const [isEditing, setIsEditing] = useState(defaultIsEditing)\n\n  const [value, setValue] = useControllableState({\n    defaultValue: defaultValue || \"\",\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n\n  /**\n   * Keep track of the previous value, so if users\n   * presses `cancel`, we can revert to it.\n   */\n  const [prevValue, setPrevValue] = useState(value)\n\n  /**\n   * Ref to help focus the input in edit mode\n   */\n  const inputRef = useRef<HTMLInputElement | HTMLTextAreaElement>(null)\n  const previewRef = useRef<any>(null)\n\n  const editButtonRef = useRef<HTMLButtonElement>(null)\n  const cancelButtonRef = useRef<HTMLElement>(null)\n  const submitButtonRef = useRef<HTMLElement>(null)\n\n  useFocusOnPointerDown({\n    ref: inputRef,\n    enabled: isEditing,\n    elements: [cancelButtonRef, submitButtonRef],\n  })\n\n  const isInteractive = !isEditing && !isDisabled\n\n  useSafeLayoutEffect(() => {\n    if (isEditing) {\n      inputRef.current?.focus()\n      if (selectAllOnFocus) inputRef.current?.select()\n    }\n  }, [])\n\n  useUpdateEffect(() => {\n    if (!isEditing) {\n      if (finalFocusRef) {\n        finalFocusRef.current?.focus()\n      } else {\n        editButtonRef.current?.focus()\n      }\n      return\n    }\n\n    inputRef.current?.focus()\n\n    if (selectAllOnFocus) {\n      inputRef.current?.select()\n    }\n\n    onEditProp?.()\n  }, [isEditing, onEditProp, selectAllOnFocus])\n\n  const onEdit = useCallback(() => {\n    if (isInteractive) {\n      setIsEditing(true)\n    }\n  }, [isInteractive])\n\n  const onUpdatePrevValue = useCallback(() => {\n    setPrevValue(value)\n  }, [value])\n\n  const onCancel = useCallback(() => {\n    setIsEditing(false)\n    setValue(prevValue)\n    onCancelProp?.(prevValue)\n    onBlurProp?.(prevValue)\n  }, [onCancelProp, onBlurProp, setValue, prevValue])\n\n  const onSubmit = useCallback(() => {\n    setIsEditing(false)\n    setPrevValue(value)\n    onSubmitProp?.(value)\n    onBlurProp?.(prevValue)\n  }, [value, onSubmitProp, onBlurProp, prevValue])\n\n  useEffect(() => {\n    if (isEditing) return\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=559561\n    const inputEl = inputRef.current\n    if (inputEl?.ownerDocument.activeElement === inputEl) {\n      inputEl?.blur()\n    }\n  }, [isEditing])\n\n  const onChange = useCallback(\n    (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n      setValue(event.currentTarget.value)\n    },\n    [setValue],\n  )\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = event.key\n\n      const keyMap: Record<string, React.KeyboardEventHandler> = {\n        Escape: onCancel,\n        Enter: (event) => {\n          if (!event.shiftKey && !event.metaKey) {\n            onSubmit()\n          }\n        },\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        action(event)\n      }\n    },\n    [onCancel, onSubmit],\n  )\n\n  const onKeyDownWithoutSubmit = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = event.key\n\n      const keyMap: Record<string, React.KeyboardEventHandler> = {\n        Escape: onCancel,\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        action(event)\n      }\n    },\n    [onCancel],\n  )\n\n  const isValueEmpty = value.length === 0\n\n  const onBlur = useCallback(\n    (event: React.FocusEvent) => {\n      if (!isEditing) return\n      const doc = event.currentTarget.ownerDocument\n      const relatedTarget = (event.relatedTarget ??\n        doc.activeElement) as HTMLElement\n      const targetIsCancel = contains(cancelButtonRef.current, relatedTarget)\n      const targetIsSubmit = contains(submitButtonRef.current, relatedTarget)\n      const isValidBlur = !targetIsCancel && !targetIsSubmit\n\n      if (isValidBlur) {\n        if (submitOnBlur) {\n          onSubmit()\n        } else {\n          onCancel()\n        }\n      }\n    },\n    [submitOnBlur, onSubmit, onCancel, isEditing],\n  )\n\n  const getPreviewProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      const tabIndex = isInteractive && isPreviewFocusable ? 0 : undefined\n      return {\n        ...props,\n        ref: mergeRefs(ref, previewRef),\n        children: isValueEmpty ? placeholder : value,\n        hidden: isEditing,\n        \"aria-disabled\": ariaAttr(isDisabled),\n        tabIndex,\n        onFocus: callAllHandlers(props.onFocus, onEdit, onUpdatePrevValue),\n      }\n    },\n    [\n      isDisabled,\n      isEditing,\n      isInteractive,\n      isPreviewFocusable,\n      isValueEmpty,\n      onEdit,\n      onUpdatePrevValue,\n      placeholder,\n      value,\n    ],\n  )\n\n  const getInputProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      hidden: !isEditing,\n      placeholder,\n      ref: mergeRefs(ref, inputRef),\n      disabled: isDisabled,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      value,\n      onBlur: callAllHandlers(props.onBlur, onBlur),\n      onChange: callAllHandlers(props.onChange, onChange),\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props.onFocus, onUpdatePrevValue),\n    }),\n    [\n      isDisabled,\n      isEditing,\n      onBlur,\n      onChange,\n      onKeyDown,\n      onUpdatePrevValue,\n      placeholder,\n      value,\n    ],\n  )\n\n  const getTextareaProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      hidden: !isEditing,\n      placeholder,\n      ref: mergeRefs(ref, inputRef),\n      disabled: isDisabled,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      value,\n      onBlur: callAllHandlers(props.onBlur, onBlur),\n      onChange: callAllHandlers(props.onChange, onChange),\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDownWithoutSubmit),\n      onFocus: callAllHandlers(props.onFocus, onUpdatePrevValue),\n    }),\n    [\n      isDisabled,\n      isEditing,\n      onBlur,\n      onChange,\n      onKeyDownWithoutSubmit,\n      onUpdatePrevValue,\n      placeholder,\n      value,\n    ],\n  )\n\n  const getEditButtonProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      \"aria-label\": \"Edit\",\n      ...props,\n      type: \"button\",\n      onClick: callAllHandlers(props.onClick, onEdit),\n      ref: mergeRefs(ref, editButtonRef),\n      disabled: isDisabled,\n    }),\n    [onEdit, isDisabled],\n  )\n\n  const getSubmitButtonProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      \"aria-label\": \"Submit\",\n      ref: mergeRefs(submitButtonRef, ref),\n      type: \"button\",\n      onClick: callAllHandlers(props.onClick, onSubmit),\n      disabled: isDisabled,\n    }),\n    [onSubmit, isDisabled],\n  )\n\n  const getCancelButtonProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      \"aria-label\": \"Cancel\",\n      id: \"cancel\",\n      ...props,\n      ref: mergeRefs(cancelButtonRef, ref),\n      type: \"button\",\n      onClick: callAllHandlers(props.onClick, onCancel),\n      disabled: isDisabled,\n    }),\n    [onCancel, isDisabled],\n  )\n\n  return {\n    isEditing,\n    isDisabled,\n    isValueEmpty,\n    value,\n    onEdit,\n    onCancel,\n    onSubmit,\n    getPreviewProps,\n    getInputProps,\n    getTextareaProps,\n    getEditButtonProps,\n    getSubmitButtonProps,\n    getCancelButtonProps,\n    htmlProps,\n  }\n}\n\nexport type UseEditableReturn = ReturnType<typeof useEditable>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}