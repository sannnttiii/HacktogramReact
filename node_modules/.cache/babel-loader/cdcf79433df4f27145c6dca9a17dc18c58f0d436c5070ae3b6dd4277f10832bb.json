{"ast":null,"code":"'use client';\n\n// src/use-tabs.ts\nimport { useClickable } from \"@chakra-ui/clickable\";\nimport { createDescendantContext } from \"@chakra-ui/descendant\";\nimport { createContext } from \"@chakra-ui/react-context\";\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\";\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\";\nimport { getValidChildren } from \"@chakra-ui/react-children-utils\";\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\";\nimport { lazyDisclosure } from \"@chakra-ui/lazy-utils\";\nimport { callAllHandlers } from \"@chakra-ui/shared-utils\";\nimport { useCallback, useEffect, useRef, useState, useId, createElement } from \"react\";\nvar [TabsDescendantsProvider, useTabsDescendantsContext, useTabsDescendants, useTabsDescendant] = createDescendantContext();\nfunction useTabs(props) {\n  var _a;\n  const {\n    defaultIndex,\n    onChange,\n    index,\n    isManual,\n    isLazy,\n    lazyBehavior = \"unmount\",\n    orientation = \"horizontal\",\n    direction = \"ltr\",\n    ...htmlProps\n  } = props;\n  const [focusedIndex, setFocusedIndex] = useState(defaultIndex != null ? defaultIndex : 0);\n  const [selectedIndex, setSelectedIndex] = useControllableState({\n    defaultValue: defaultIndex != null ? defaultIndex : 0,\n    value: index,\n    onChange\n  });\n  useEffect(() => {\n    if (index != null) {\n      setFocusedIndex(index);\n    }\n  }, [index]);\n  const descendants = useTabsDescendants();\n  const uuid = useId();\n  const uid = (_a = props.id) != null ? _a : uuid;\n  const id = `tabs-${uid}`;\n  return {\n    id,\n    selectedIndex,\n    focusedIndex,\n    setSelectedIndex,\n    setFocusedIndex,\n    isManual,\n    isLazy,\n    lazyBehavior,\n    orientation,\n    descendants,\n    direction,\n    htmlProps\n  };\n}\nvar [TabsProvider, useTabsContext] = createContext({\n  name: \"TabsContext\",\n  errorMessage: \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\"\n});\nfunction useTabList(props) {\n  const {\n    focusedIndex,\n    orientation,\n    direction\n  } = useTabsContext();\n  const descendants = useTabsDescendantsContext();\n  const onKeyDown = useCallback(event => {\n    const nextTab = () => {\n      var _a;\n      const next = descendants.nextEnabled(focusedIndex);\n      if (next) (_a = next.node) == null ? void 0 : _a.focus();\n    };\n    const prevTab = () => {\n      var _a;\n      const prev = descendants.prevEnabled(focusedIndex);\n      if (prev) (_a = prev.node) == null ? void 0 : _a.focus();\n    };\n    const firstTab = () => {\n      var _a;\n      const first = descendants.firstEnabled();\n      if (first) (_a = first.node) == null ? void 0 : _a.focus();\n    };\n    const lastTab = () => {\n      var _a;\n      const last = descendants.lastEnabled();\n      if (last) (_a = last.node) == null ? void 0 : _a.focus();\n    };\n    const isHorizontal = orientation === \"horizontal\";\n    const isVertical = orientation === \"vertical\";\n    const eventKey = event.key;\n    const ArrowStart = direction === \"ltr\" ? \"ArrowLeft\" : \"ArrowRight\";\n    const ArrowEnd = direction === \"ltr\" ? \"ArrowRight\" : \"ArrowLeft\";\n    const keyMap = {\n      [ArrowStart]: () => isHorizontal && prevTab(),\n      [ArrowEnd]: () => isHorizontal && nextTab(),\n      ArrowDown: () => isVertical && nextTab(),\n      ArrowUp: () => isVertical && prevTab(),\n      Home: firstTab,\n      End: lastTab\n    };\n    const action = keyMap[eventKey];\n    if (action) {\n      event.preventDefault();\n      action(event);\n    }\n  }, [descendants, focusedIndex, orientation, direction]);\n  return {\n    ...props,\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n  };\n}\nfunction useTab(props) {\n  const {\n    isDisabled = false,\n    isFocusable = false,\n    ...htmlProps\n  } = props;\n  const {\n    setSelectedIndex,\n    isManual,\n    id,\n    setFocusedIndex,\n    selectedIndex\n  } = useTabsContext();\n  const {\n    index,\n    register\n  } = useTabsDescendant({\n    disabled: isDisabled && !isFocusable\n  });\n  const isSelected = index === selectedIndex;\n  const onClick = () => {\n    setSelectedIndex(index);\n  };\n  const onFocus = () => {\n    setFocusedIndex(index);\n    const isDisabledButFocusable = isDisabled && isFocusable;\n    const shouldSelect = !isManual && !isDisabledButFocusable;\n    if (shouldSelect) {\n      setSelectedIndex(index);\n    }\n  };\n  const clickableProps = useClickable({\n    ...htmlProps,\n    ref: mergeRefs(register, props.ref),\n    isDisabled,\n    isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick)\n  });\n  const type = \"button\";\n  return {\n    ...clickableProps,\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? void 0 : callAllHandlers(props.onFocus, onFocus)\n  };\n}\nvar [TabPanelProvider, useTabPanelContext] = createContext({});\nfunction useTabPanels(props) {\n  const context = useTabsContext();\n  const {\n    id,\n    selectedIndex\n  } = context;\n  const validChildren = getValidChildren(props.children);\n  const children = validChildren.map((child, index) => createElement(TabPanelProvider, {\n    key: index,\n    value: {\n      isSelected: index === selectedIndex,\n      id: makeTabPanelId(id, index),\n      tabId: makeTabId(id, index),\n      selectedIndex\n    }\n  }, child));\n  return {\n    ...props,\n    children\n  };\n}\nfunction useTabPanel(props) {\n  const {\n    children,\n    ...htmlProps\n  } = props;\n  const {\n    isLazy,\n    lazyBehavior\n  } = useTabsContext();\n  const {\n    isSelected,\n    id,\n    tabId\n  } = useTabPanelContext();\n  const hasBeenSelected = useRef(false);\n  if (isSelected) {\n    hasBeenSelected.current = true;\n  }\n  const shouldRenderChildren = lazyDisclosure({\n    wasSelected: hasBeenSelected.current,\n    isSelected,\n    enabled: isLazy,\n    mode: lazyBehavior\n  });\n  return {\n    // Puts the tabpanel in the page `Tab` sequence.\n    tabIndex: 0,\n    ...htmlProps,\n    children: shouldRenderChildren ? children : null,\n    role: \"tabpanel\",\n    \"aria-labelledby\": tabId,\n    hidden: !isSelected,\n    id\n  };\n}\nfunction useTabIndicator() {\n  const context = useTabsContext();\n  const descendants = useTabsDescendantsContext();\n  const {\n    selectedIndex,\n    orientation\n  } = context;\n  const isHorizontal = orientation === \"horizontal\";\n  const isVertical = orientation === \"vertical\";\n  const [rect, setRect] = useState(() => {\n    if (isHorizontal) return {\n      left: 0,\n      width: 0\n    };\n    if (isVertical) return {\n      top: 0,\n      height: 0\n    };\n    return void 0;\n  });\n  const [hasMeasured, setHasMeasured] = useState(false);\n  useSafeLayoutEffect(() => {\n    if (selectedIndex == null) return;\n    const tab = descendants.item(selectedIndex);\n    if (tab == null) return;\n    if (isHorizontal) {\n      setRect({\n        left: tab.node.offsetLeft,\n        width: tab.node.offsetWidth\n      });\n    }\n    if (isVertical) {\n      setRect({\n        top: tab.node.offsetTop,\n        height: tab.node.offsetHeight\n      });\n    }\n    const id = requestAnimationFrame(() => {\n      setHasMeasured(true);\n    });\n    return () => {\n      if (id) {\n        cancelAnimationFrame(id);\n      }\n    };\n  }, [selectedIndex, isHorizontal, isVertical, descendants]);\n  return {\n    position: \"absolute\",\n    transitionProperty: \"left, right, top, bottom, height, width\",\n    transitionDuration: hasMeasured ? \"200ms\" : \"0ms\",\n    transitionTimingFunction: \"cubic-bezier(0, 0, 0.2, 1)\",\n    ...rect\n  };\n}\nfunction makeTabId(id, index) {\n  return `${id}--tab-${index}`;\n}\nfunction makeTabPanelId(id, index) {\n  return `${id}--tabpanel-${index}`;\n}\nexport { TabsDescendantsProvider, useTabsDescendantsContext, useTabsDescendants, useTabsDescendant, useTabs, TabsProvider, useTabsContext, useTabList, useTab, useTabPanels, useTabPanel, useTabIndicator };","map":{"version":3,"mappings":"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","names":["useClickable","createDescendantContext","createContext","useSafeLayoutEffect","useControllableState","getValidChildren","mergeRefs","lazyDisclosure","callAllHandlers","useCallback","useEffect","useRef","useState","useId","createElement","TabsDescendantsProvider","useTabsDescendantsContext","useTabsDescendants","useTabsDescendant","useTabs","props","defaultIndex","onChange","index","isManual","isLazy","lazyBehavior","orientation","direction","htmlProps","focusedIndex","setFocusedIndex","selectedIndex","setSelectedIndex","defaultValue","value","descendants","uuid","uid","_a","id","TabsProvider","useTabsContext","name","errorMessage","useTabList","onKeyDown","event","nextTab","next","nextEnabled","node","focus","prevTab","prev","prevEnabled","firstTab","first","firstEnabled","lastTab","last","lastEnabled","isHorizontal","isVertical","eventKey","key","ArrowStart","ArrowEnd","keyMap","ArrowDown","ArrowUp","Home","End","action","preventDefault","role","useTab","isDisabled","isFocusable","register","disabled","isSelected","onClick","onFocus","isDisabledButFocusable","shouldSelect","clickableProps","ref","type","makeTabId","tabIndex","makeTabPanelId","TabPanelProvider","useTabPanelContext","useTabPanels","context","validChildren","children","map","child","tabId","useTabPanel","hasBeenSelected","current","shouldRenderChildren","wasSelected","enabled","mode","hidden","useTabIndicator","rect","setRect","left","width","top","height","hasMeasured","setHasMeasured","tab","item","offsetLeft","offsetWidth","offsetTop","offsetHeight","requestAnimationFrame","cancelAnimationFrame","position","transitionProperty","transitionDuration","transitionTimingFunction"],"sources":["/Users/santitri1205/Documents/SkillAcademy/BATCH2/react-final-project-hacktogram-v1/node_modules/@chakra-ui/tabs/src/use-tabs.ts"],"sourcesContent":["import { useClickable, UseClickableProps } from \"@chakra-ui/clickable\"\nimport { createDescendantContext } from \"@chakra-ui/descendant\"\nimport { createContext } from \"@chakra-ui/react-context\"\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\"\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\"\nimport { getValidChildren } from \"@chakra-ui/react-children-utils\"\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\"\nimport { lazyDisclosure, LazyMode } from \"@chakra-ui/lazy-utils\"\nimport { callAllHandlers } from \"@chakra-ui/shared-utils\"\nimport {\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  useId,\n  createElement,\n} from \"react\"\n\n/* -------------------------------------------------------------------------------------------------\n * Create context to track descendants and their indices\n * -----------------------------------------------------------------------------------------------*/\n\nexport const [\n  TabsDescendantsProvider,\n  useTabsDescendantsContext,\n  useTabsDescendants,\n  useTabsDescendant,\n] = createDescendantContext<HTMLButtonElement>()\n\n/* -------------------------------------------------------------------------------------------------\n * useTabs - The root react hook that manages all tab items\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UseTabsProps {\n  /**\n   * The orientation of the tab list.\n   * @default \"horizontal\"\n   */\n  orientation?: \"vertical\" | \"horizontal\"\n  /**\n   * If `true`, the tabs will be manually activated and\n   * display its panel by pressing Space or Enter.\n   *\n   * If `false`, the tabs will be automatically activated\n   * and their panel is displayed when they receive focus.\n   *\n   * @default false\n   */\n  isManual?: boolean\n  /**\n   * Callback when the index (controlled or un-controlled) changes.\n   */\n  onChange?: (index: number) => void\n  /**\n   * The index of the selected tab (in controlled mode)\n   */\n  index?: number\n  /**\n   * The initial index of the selected tab (in uncontrolled mode)\n   */\n  defaultIndex?: number\n  /**\n   * The id of the tab\n   */\n  id?: string\n  /**\n   * Performance ðŸš€:\n   * If `true`, rendering of the tab panel's will be deferred until it is selected.\n   * @default false\n   */\n  isLazy?: boolean\n  /**\n   * Performance ðŸš€:\n   * The lazy behavior of tab panels' content when not active.\n   * Only works when `isLazy={true}`\n   *\n   * - \"unmount\": The content of inactive tab panels are always unmounted.\n   * - \"keepMounted\": The content of inactive tab panels is initially unmounted,\n   * but stays mounted when selected.\n   *\n   * @default \"unmount\"\n   */\n  lazyBehavior?: LazyMode\n  /**\n   * The writing mode direction.\n   *\n   * - When in RTL, the left and right navigation is flipped\n   * @default \"ltr\"\n   */\n  direction?: \"rtl\" | \"ltr\"\n}\n\n/**\n * Tabs hook that provides all the states, and accessibility\n * helpers to keep all things working properly.\n *\n * Its returned object will be passed unto a Context Provider\n * so all child components can read from it.\n * There is no document link yet\n * @see Docs https://chakra-ui.com/docs/components/useTabs\n * @see WAI-ARIA https://www.w3.org/WAI/ARIA/apg/patterns/tabpanel/\n */\nexport function useTabs(props: UseTabsProps) {\n  const {\n    defaultIndex,\n    onChange,\n    index,\n    isManual,\n    isLazy,\n    lazyBehavior = \"unmount\",\n    orientation = \"horizontal\",\n    direction = \"ltr\",\n    ...htmlProps\n  } = props\n\n  /**\n   * We use this to keep track of the index of the focused tab.\n   *\n   * Tabs can be automatically activated, this means selection follows focus.\n   * When we navigate with the arrow keys, we move focus and selection to next/prev tab\n   *\n   * Tabs can also be manually activated, this means selection does not follow focus.\n   * When we navigate with the arrow keys, we only move focus NOT selection. The user\n   * will need not manually activate the tab using `Enter` or `Space`.\n   *\n   * This is why we need to keep track of the `focusedIndex` and `selectedIndex`\n   */\n  const [focusedIndex, setFocusedIndex] = useState(defaultIndex ?? 0)\n\n  const [selectedIndex, setSelectedIndex] = useControllableState({\n    defaultValue: defaultIndex ?? 0,\n    value: index,\n    onChange,\n  })\n\n  /**\n   * Sync focused `index` with controlled `selectedIndex` (which is the `props.index`)\n   */\n  useEffect(() => {\n    if (index != null) {\n      setFocusedIndex(index)\n    }\n  }, [index])\n\n  /**\n   * Think of `useDescendants` as a register for the tab nodes.\n   */\n  const descendants = useTabsDescendants()\n\n  /**\n   * Generate a unique id or use user-provided id for the tabs widget\n   */\n  const uuid = useId()\n  const uid = props.id ?? uuid\n  const id = `tabs-${uid}`\n\n  return {\n    id,\n    selectedIndex,\n    focusedIndex,\n    setSelectedIndex,\n    setFocusedIndex,\n    isManual,\n    isLazy,\n    lazyBehavior,\n    orientation,\n    descendants,\n    direction,\n    htmlProps,\n  }\n}\n\nexport type UseTabsReturn = Omit<\n  ReturnType<typeof useTabs>,\n  \"htmlProps\" | \"descendants\"\n>\n\nexport const [TabsProvider, useTabsContext] = createContext<UseTabsReturn>({\n  name: \"TabsContext\",\n  errorMessage:\n    \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\",\n})\n\nexport interface UseTabListProps {\n  children?: React.ReactNode\n  onKeyDown?: React.KeyboardEventHandler\n  ref?: React.Ref<any>\n}\n\n/**\n * Tabs hook to manage multiple tab buttons,\n * and ensures only one tab is selected per time.\n *\n * @param props props object for the tablist\n */\nexport function useTabList<P extends UseTabListProps>(props: P) {\n  const { focusedIndex, orientation, direction } = useTabsContext()\n\n  const descendants = useTabsDescendantsContext()\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const nextTab = () => {\n        const next = descendants.nextEnabled(focusedIndex)\n        if (next) next.node?.focus()\n      }\n      const prevTab = () => {\n        const prev = descendants.prevEnabled(focusedIndex)\n        if (prev) prev.node?.focus()\n      }\n      const firstTab = () => {\n        const first = descendants.firstEnabled()\n        if (first) first.node?.focus()\n      }\n      const lastTab = () => {\n        const last = descendants.lastEnabled()\n        if (last) last.node?.focus()\n      }\n\n      const isHorizontal = orientation === \"horizontal\"\n      const isVertical = orientation === \"vertical\"\n\n      const eventKey = event.key\n\n      const ArrowStart = direction === \"ltr\" ? \"ArrowLeft\" : \"ArrowRight\"\n      const ArrowEnd = direction === \"ltr\" ? \"ArrowRight\" : \"ArrowLeft\"\n\n      const keyMap: Record<string, React.KeyboardEventHandler> = {\n        [ArrowStart]: () => isHorizontal && prevTab(),\n        [ArrowEnd]: () => isHorizontal && nextTab(),\n        ArrowDown: () => isVertical && nextTab(),\n        ArrowUp: () => isVertical && prevTab(),\n        Home: firstTab,\n        End: lastTab,\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        action(event)\n      }\n    },\n    [descendants, focusedIndex, orientation, direction],\n  )\n\n  return {\n    ...props,\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n  }\n}\n\nexport type UseTabListReturn = ReturnType<typeof useTabList>\n\nexport interface UseTabOptions {\n  /**\n   * If `true`, the `Tab` won't be toggleable\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   * If `true` and `isDisabled`, the `Tab` will be focusable but not interactive.\n   * @default false\n   */\n  isFocusable?: boolean\n}\n\nexport interface UseTabProps\n  extends Omit<UseClickableProps, \"color\">,\n    UseTabOptions {}\n\n/**\n * Tabs hook to manage each tab button.\n *\n * A tab can be disabled and focusable, or both,\n * hence the use of `useClickable` to handle this scenario\n */\nexport function useTab<P extends UseTabProps>(props: P) {\n  const { isDisabled = false, isFocusable = false, ...htmlProps } = props\n\n  const { setSelectedIndex, isManual, id, setFocusedIndex, selectedIndex } =\n    useTabsContext()\n\n  const { index, register } = useTabsDescendant({\n    disabled: isDisabled && !isFocusable,\n  })\n\n  const isSelected = index === selectedIndex\n\n  const onClick = () => {\n    setSelectedIndex(index)\n  }\n\n  const onFocus = () => {\n    setFocusedIndex(index)\n    const isDisabledButFocusable = isDisabled && isFocusable\n    const shouldSelect = !isManual && !isDisabledButFocusable\n    if (shouldSelect) {\n      setSelectedIndex(index)\n    }\n  }\n\n  const clickableProps = useClickable({\n    ...htmlProps,\n    ref: mergeRefs(register, props.ref),\n    isDisabled,\n    isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick),\n  })\n\n  const type: \"button\" | \"submit\" | \"reset\" = \"button\"\n\n  return {\n    ...clickableProps,\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? undefined : callAllHandlers(props.onFocus, onFocus),\n  }\n}\n\nexport interface UseTabPanelsProps {\n  children?: React.ReactNode\n}\n\nconst [TabPanelProvider, useTabPanelContext] = createContext<{\n  isSelected: boolean\n  id: string\n  tabId: string\n  selectedIndex: number\n}>({})\n\n/**\n * Tabs hook for managing the visibility of multiple tab panels.\n *\n * Since only one panel can be show at a time, we use `cloneElement`\n * to inject `selected` panel to each TabPanel.\n *\n * It returns a cloned version of its children with\n * all functionality included.\n */\nexport function useTabPanels<P extends UseTabPanelsProps>(props: P) {\n  const context = useTabsContext()\n\n  const { id, selectedIndex } = context\n\n  const validChildren = getValidChildren(props.children)\n\n  const children = validChildren.map((child, index) =>\n    createElement(\n      TabPanelProvider,\n      {\n        key: index,\n        value: {\n          isSelected: index === selectedIndex,\n          id: makeTabPanelId(id, index),\n          tabId: makeTabId(id, index),\n          selectedIndex,\n        },\n      },\n      child,\n    ),\n  )\n\n  return { ...props, children }\n}\n\n/**\n * Tabs hook for managing the visible/hidden states\n * of the tab panel.\n *\n * @param props props object for the tab panel\n */\nexport function useTabPanel(props: Record<string, any>) {\n  const { children, ...htmlProps } = props\n  const { isLazy, lazyBehavior } = useTabsContext()\n  const { isSelected, id, tabId } = useTabPanelContext()\n\n  const hasBeenSelected = useRef(false)\n  if (isSelected) {\n    hasBeenSelected.current = true\n  }\n\n  const shouldRenderChildren = lazyDisclosure({\n    wasSelected: hasBeenSelected.current,\n    isSelected,\n    enabled: isLazy,\n    mode: lazyBehavior,\n  })\n\n  return {\n    // Puts the tabpanel in the page `Tab` sequence.\n    tabIndex: 0,\n    ...htmlProps,\n    children: shouldRenderChildren ? children : null,\n    role: \"tabpanel\",\n    \"aria-labelledby\": tabId,\n    hidden: !isSelected,\n    id,\n  }\n}\n\n/**\n * Tabs hook to show an animated indicators that\n * follows the active tab.\n *\n * The way we do it is by measuring the DOM Rect (or dimensions)\n * of the active tab, and return that as CSS style for\n * the indicator.\n */\nexport function useTabIndicator(): React.CSSProperties {\n  const context = useTabsContext()\n  const descendants = useTabsDescendantsContext()\n\n  const { selectedIndex, orientation } = context\n\n  const isHorizontal = orientation === \"horizontal\"\n  const isVertical = orientation === \"vertical\"\n\n  // Get the clientRect of the selected tab\n  const [rect, setRect] = useState(() => {\n    if (isHorizontal) return { left: 0, width: 0 }\n    if (isVertical) return { top: 0, height: 0 }\n    return undefined\n  })\n\n  const [hasMeasured, setHasMeasured] = useState(false)\n\n  // Update the selected tab rect when the selectedIndex changes\n  useSafeLayoutEffect(() => {\n    if (selectedIndex == null) return\n\n    const tab = descendants.item(selectedIndex)\n    if (tab == null) return\n\n    // Horizontal Tab: Calculate width and left distance\n    if (isHorizontal) {\n      setRect({ left: tab.node.offsetLeft, width: tab.node.offsetWidth })\n    }\n\n    // Vertical Tab: Calculate height and top distance\n    if (isVertical) {\n      setRect({ top: tab.node.offsetTop, height: tab.node.offsetHeight })\n    }\n\n    // Prevent unwanted transition from 0 to measured rect\n    // by setting the measured state in the next tick\n    const id = requestAnimationFrame(() => {\n      setHasMeasured(true)\n    })\n\n    return () => {\n      if (id) {\n        cancelAnimationFrame(id)\n      }\n    }\n  }, [selectedIndex, isHorizontal, isVertical, descendants])\n\n  return {\n    position: \"absolute\",\n    transitionProperty: \"left, right, top, bottom, height, width\",\n    transitionDuration: hasMeasured ? \"200ms\" : \"0ms\",\n    transitionTimingFunction: \"cubic-bezier(0, 0, 0.2, 1)\",\n    ...rect,\n  }\n}\n\nfunction makeTabId(id: string, index: number) {\n  return `${id}--tab-${index}`\n}\n\nfunction makeTabPanelId(id: string, index: number) {\n  return `${id}--tabpanel-${index}`\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}