{"ast":null,"code":"'use client';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// src/pan-event.ts\nimport { addPointerEvent, getEventPoint, isMultiTouchEvent } from \"@chakra-ui/event-utils\";\nimport sync, { cancelSync, getFrameData } from \"framesync\";\nvar PanEvent = class {\n  constructor(event, handlers, threshold) {\n    /**\n     * We use this to keep track of the `x` and `y` pan session history\n     * as the pan event happens. It helps to calculate the `offset` and `delta`\n     */\n    __publicField(this, \"history\", []);\n    // The pointer event that started the pan session\n    __publicField(this, \"startEvent\", null);\n    // The current pointer event for the pan session\n    __publicField(this, \"lastEvent\", null);\n    // The current pointer event info for the pan session\n    __publicField(this, \"lastEventInfo\", null);\n    __publicField(this, \"handlers\", {});\n    __publicField(this, \"removeListeners\", () => {});\n    /**\n     * Minimal pan distance required before recognizing the pan.\n     * @default \"3px\"\n     */\n    __publicField(this, \"threshold\", 3);\n    __publicField(this, \"win\");\n    __publicField(this, \"updatePoint\", () => {\n      if (!(this.lastEvent && this.lastEventInfo)) return;\n      const info = getPanInfo(this.lastEventInfo, this.history);\n      const isPanStarted = this.startEvent !== null;\n      const isDistancePastThreshold = distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= this.threshold;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      const {\n        timestamp\n      } = getFrameData();\n      this.history.push({\n        ...info.point,\n        timestamp\n      });\n      const {\n        onStart,\n        onMove\n      } = this.handlers;\n      if (!isPanStarted) {\n        onStart == null ? void 0 : onStart(this.lastEvent, info);\n        this.startEvent = this.lastEvent;\n      }\n      onMove == null ? void 0 : onMove(this.lastEvent, info);\n    });\n    __publicField(this, \"onPointerMove\", (event, info) => {\n      this.lastEvent = event;\n      this.lastEventInfo = info;\n      sync.update(this.updatePoint, true);\n    });\n    __publicField(this, \"onPointerUp\", (event, info) => {\n      const panInfo = getPanInfo(info, this.history);\n      const {\n        onEnd,\n        onSessionEnd\n      } = this.handlers;\n      onSessionEnd == null ? void 0 : onSessionEnd(event, panInfo);\n      this.end();\n      if (!onEnd || !this.startEvent) return;\n      onEnd == null ? void 0 : onEnd(event, panInfo);\n    });\n    var _a;\n    this.win = (_a = event.view) != null ? _a : window;\n    if (isMultiTouchEvent(event)) return;\n    this.handlers = handlers;\n    if (threshold) {\n      this.threshold = threshold;\n    }\n    event.stopPropagation();\n    event.preventDefault();\n    const info = {\n      point: getEventPoint(event)\n    };\n    const {\n      timestamp\n    } = getFrameData();\n    this.history = [{\n      ...info.point,\n      timestamp\n    }];\n    const {\n      onSessionStart\n    } = handlers;\n    onSessionStart == null ? void 0 : onSessionStart(event, getPanInfo(info, this.history));\n    this.removeListeners = pipe(addPointerEvent(this.win, \"pointermove\", this.onPointerMove), addPointerEvent(this.win, \"pointerup\", this.onPointerUp), addPointerEvent(this.win, \"pointercancel\", this.onPointerUp));\n  }\n  updateHandlers(handlers) {\n    this.handlers = handlers;\n  }\n  end() {\n    var _a;\n    (_a = this.removeListeners) == null ? void 0 : _a.call(this);\n    cancelSync.update(this.updatePoint);\n  }\n};\nfunction subtract(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\nfunction getPanInfo(info, history) {\n  return {\n    point: info.point,\n    delta: subtract(info.point, history[history.length - 1]),\n    offset: subtract(info.point, history[0]),\n    velocity: getVelocity(history, 0.1)\n  };\n}\nvar toMilliseconds = v => v * 1e3;\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  let i = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = history[history.length - 1];\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > toMilliseconds(timeDelta)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}\nfunction pipe() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n  return v => fns.reduce((a, b) => b(a), v);\n}\nfunction distance1D(a, b) {\n  return Math.abs(a - b);\n}\nfunction isPoint(point) {\n  return \"x\" in point && \"y\" in point;\n}\nfunction distance(a, b) {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return distance1D(a, b);\n  }\n  if (isPoint(a) && isPoint(b)) {\n    const xDelta = distance1D(a.x, b.x);\n    const yDelta = distance1D(a.y, b.y);\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n  }\n  return 0;\n}\nexport { PanEvent, distance };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;AAAA,SACEA,iBACAC,eACAC,yBACK;AACP,OAAOC,QAAQC,YAAYC,oBAAoB;AAcxC,IAAMC,WAAN,MAAe;EA4BpBC,YACEC,OACAC,UACAC,WACA;IA3BF;AAAA;AAAA;AAAA;IAAAC,oBAAQ,WAA2B,EAAC;IAGpC;IAAAA,oBAAQ,cAAqC;IAG7C;IAAAA,oBAAQ,aAAoC;IAG5C;IAAAA,oBAAQ,iBAAyC;IAEjDA,oBAAQ,YAAsC,CAAC;IAE/CA,oBAAQ,mBAA4B,MAAM,CAAC;IAM3C;AAAA;AAAA;AAAA;IAAAA,oBAAQ,aAAY;IAEpBA,oBAAQ;IAwCRA,oBAAQ,eAAc,MAAM;MAC1B,IAAI,EAAE,KAAKC,aAAa,KAAKC,gBAAgB;MAE7C,MAAMC,OAAOC,WAAW,KAAKF,eAAe,KAAKG,OAAO;MAExD,MAAMC,eAAe,KAAKC,eAAe;MAEzC,MAAMC,0BACJC,SAASN,KAAKO,QAAQ;QAAEC,GAAG;QAAGC,GAAG;MAAE,CAAC,KAAK,KAAKb;MAEhD,IAAI,CAACO,gBAAgB,CAACE,yBAAyB;MAE/C,MAAM;QAAEK;MAAU,IAAInB,cAAa;MACnC,KAAKW,QAAQS,KAAK;QAAE,GAAGX,KAAKY;QAAOF;MAAU,CAAC;MAE9C,MAAM;QAAEG;QAASC;MAAO,IAAI,KAAKnB;MAEjC,IAAI,CAACQ,cAAc;QACjBU,mCAAU,KAAKf,WAAWE;QAC1B,KAAKI,aAAa,KAAKN;MACzB;MAEAgB,iCAAS,KAAKhB,WAAWE;IAC3B;IAEAH,oBAAQ,iBAAgB,CAACH,OAAwBM,SAA2B;MAC1E,KAAKF,YAAYJ;MACjB,KAAKK,gBAAgBC;MAGrBX,KAAK0B,OAAO,KAAKC,aAAa,IAAI;IACpC;IAEAnB,oBAAQ,eAAc,CAACH,OAAwBM,SAA2B;MAExE,MAAMiB,UAAUhB,WAAWD,MAAM,KAAKE,OAAO;MAC7C,MAAM;QAAEgB;QAAOC;MAAa,IAAI,KAAKxB;MAErCwB,6CAAezB,OAAOuB;MACtB,KAAKG,KAAI;MAIT,IAAI,CAACF,SAAS,CAAC,KAAKd,YAAY;MAEhCc,+BAAQxB,OAAOuB;IACjB;IAnIF;IAoDI,KAAKI,OAAOC,WAAMC,SAAN,YAAcC;IAG1B,IAAIpC,kBAAkBM,KAAK,GAAG;IAE9B,KAAKC,WAAWA;IAEhB,IAAIC,WAAW;MACb,KAAKA,YAAYA;IACnB;IAGAF,MAAM+B,iBAAgB;IACtB/B,MAAMgC,gBAAe;IAIrB,MAAM1B,OAAO;MAAEY,OAAOzB,cAAcO,KAAK;IAAE;IAC3C,MAAM;MAAEgB;IAAU,IAAInB,cAAa;IACnC,KAAKW,UAAU,CAAC;MAAE,GAAGF,KAAKY;MAAOF;IAAU,CAAC;IAG5C,MAAM;MAAEiB;IAAe,IAAIhC;IAC3BgC,iDAAiBjC,OAAOO,WAAWD,MAAM,KAAKE,OAAO;IAGrD,KAAK0B,kBAAkBC,KACrB3C,gBAAgB,KAAKmC,KAAK,eAAe,KAAKS,aAAa,GAC3D5C,gBAAgB,KAAKmC,KAAK,aAAa,KAAKU,WAAW,GACvD7C,gBAAgB,KAAKmC,KAAK,iBAAiB,KAAKU,WAAW,EAC7D;EACF;EAkDAC,eAAerC,UAAqC;IAClD,KAAKA,WAAWA;EAClB;EAEAyB,MAAM;IAzIR;IA0II,WAAKQ,oBAAL;IACAtC,WAAWyB,OAAO,KAAKC,WAAW;EACpC;AACF;AAMA,SAASiB,SAASC,GAAUC,GAAU;EACpC,OAAO;IAAE3B,GAAG0B,EAAE1B,IAAI2B,EAAE3B;IAAGC,GAAGyB,EAAEzB,IAAI0B,EAAE1B;EAAE;AACtC;AAEA,SAASR,WAAWD,MAAwBE,SAA0B;EACpE,OAAO;IACLU,OAAOZ,KAAKY;IACZwB,OAAOH,SAASjC,KAAKY,OAAOV,QAAQA,QAAQmC,SAAS,CAAC,CAAC;IACvD9B,QAAQ0B,SAASjC,KAAKY,OAAOV,QAAQ,CAAC,CAAC;IACvCoC,UAAUC,YAAYrC,SAAS,GAAG;EACpC;AACF;AAEA,IAAMsC,iBAAkBC,KAAcA,IAAI;AAE1C,SAASF,YAAYrC,SAA6BwC,WAA0B;EAC1E,IAAIxC,QAAQmC,SAAS,GAAG;IACtB,OAAO;MAAE7B,GAAG;MAAGC,GAAG;IAAE;EACtB;EAEA,IAAIkC,IAAIzC,QAAQmC,SAAS;EACzB,IAAIO,mBAA4C;EAChD,MAAMC,YAAY3C,QAAQA,QAAQmC,SAAS,CAAC;EAC5C,OAAOM,KAAK,GAAG;IACbC,mBAAmB1C,QAAQyC,CAAC;IAC5B,IACEE,UAAUnC,YAAYkC,iBAAiBlC,YACvC8B,eAAeE,SAAS,GACxB;MACA;IACF;IACAC;EACF;EAEA,IAAI,CAACC,kBAAkB;IACrB,OAAO;MAAEpC,GAAG;MAAGC,GAAG;IAAE;EACtB;EAEA,MAAMqC,QAAQD,UAAUnC,YAAYkC,iBAAiBlC,aAAa;EAClE,IAAIoC,SAAS,GAAG;IACd,OAAO;MAAEtC,GAAG;MAAGC,GAAG;IAAE;EACtB;EAEA,MAAMsC,kBAAkB;IACtBvC,IAAIqC,UAAUrC,IAAIoC,iBAAiBpC,KAAKsC;IACxCrC,IAAIoC,UAAUpC,IAAImC,iBAAiBnC,KAAKqC;EAC1C;EAEA,IAAIC,gBAAgBvC,MAAMwC,UAAU;IAClCD,gBAAgBvC,IAAI;EACtB;EACA,IAAIuC,gBAAgBtC,MAAMuC,UAAU;IAClCD,gBAAgBtC,IAAI;EACtB;EAEA,OAAOsC;AACT;AAEA,SAASlB,OAAoC;EAAA,kCAAzBoB;IAAAA;EAAA;EAClB,OAAQR,KAASQ,IAAIC,OAAO,CAAChB,GAAGC,MAAMA,EAAED,CAAC,GAAGO,CAAC;AAC/C;AAEA,SAASU,WAAWjB,GAAWC,GAAW;EACxC,OAAOiB,KAAKC,IAAInB,IAAIC,CAAC;AACvB;AAEA,SAASmB,QAAQ1C,OAA+C;EAC9D,OAAO,OAAOA,SAAS,OAAOA;AAChC;AAEO,SAASN,SAAmC4B,GAAMC,GAAM;EAC7D,IAAI,OAAOD,MAAM,YAAY,OAAOC,MAAM,UAAU;IAClD,OAAOgB,WAAWjB,GAAGC,CAAC;EACxB;EAEA,IAAImB,QAAQpB,CAAC,KAAKoB,QAAQnB,CAAC,GAAG;IAC5B,MAAMoB,SAASJ,WAAWjB,EAAE1B,GAAG2B,EAAE3B,CAAC;IAClC,MAAMgD,SAASL,WAAWjB,EAAEzB,GAAG0B,EAAE1B,CAAC;IAClC,OAAO2C,KAAKK,KAAKF,UAAU,IAAIC,UAAU,CAAC;EAC5C;EAEA,OAAO;AACT","names":["addPointerEvent","getEventPoint","isMultiTouchEvent","sync","cancelSync","getFrameData","PanEvent","constructor","event","handlers","threshold","__publicField","lastEvent","lastEventInfo","info","getPanInfo","history","isPanStarted","startEvent","isDistancePastThreshold","distance","offset","x","y","timestamp","push","point","onStart","onMove","update","updatePoint","panInfo","onEnd","onSessionEnd","end","win","_a","view","window","stopPropagation","preventDefault","onSessionStart","removeListeners","pipe","onPointerMove","onPointerUp","updateHandlers","subtract","a","b","delta","length","velocity","getVelocity","toMilliseconds","v","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity","fns","reduce","distance1D","Math","abs","isPoint","xDelta","yDelta","sqrt"],"sources":["/Users/santitri1205/Documents/SkillAcademy/BATCH2/react-final-project-hacktogram-v1/node_modules/@chakra-ui/react-use-pan-event/src/pan-event.ts"],"sourcesContent":["import {\n  addPointerEvent,\n  getEventPoint,\n  isMultiTouchEvent,\n} from \"@chakra-ui/event-utils\"\nimport sync, { cancelSync, getFrameData } from \"framesync\"\nimport {\n  AnyPointerEvent,\n  PanEventHandlers,\n  PanEventHistory,\n  Point,\n  PointerEventInfo,\n  TimestampedPoint,\n} from \"./types\"\n\n/**\n * A Pan Session is recognized when the pointer is down\n * and moved in the allowed direction.\n */\nexport class PanEvent {\n  /**\n   * We use this to keep track of the `x` and `y` pan session history\n   * as the pan event happens. It helps to calculate the `offset` and `delta`\n   */\n  private history: PanEventHistory = []\n\n  // The pointer event that started the pan session\n  private startEvent: AnyPointerEvent | null = null\n\n  // The current pointer event for the pan session\n  private lastEvent: AnyPointerEvent | null = null\n\n  // The current pointer event info for the pan session\n  private lastEventInfo: PointerEventInfo | null = null\n\n  private handlers: Partial<PanEventHandlers> = {}\n\n  private removeListeners: Function = () => {}\n\n  /**\n   * Minimal pan distance required before recognizing the pan.\n   * @default \"3px\"\n   */\n  private threshold = 3\n\n  private win: typeof globalThis\n\n  constructor(\n    event: AnyPointerEvent,\n    handlers: Partial<PanEventHandlers>,\n    threshold?: number,\n  ) {\n    this.win = (event.view ?? window) as typeof globalThis.window\n\n    // If we have more than one touch, don't start detecting this gesture\n    if (isMultiTouchEvent(event)) return\n\n    this.handlers = handlers\n\n    if (threshold) {\n      this.threshold = threshold\n    }\n\n    // stop default browser behavior\n    event.stopPropagation()\n    event.preventDefault()\n\n    // get and save the `pointerdown` event info in history\n    // we'll use it to compute the `offset`\n    const info = { point: getEventPoint(event) }\n    const { timestamp } = getFrameData()\n    this.history = [{ ...info.point, timestamp }]\n\n    // notify pan session start\n    const { onSessionStart } = handlers\n    onSessionStart?.(event, getPanInfo(info, this.history))\n\n    // attach event listeners and return a single function to remove them all\n    this.removeListeners = pipe(\n      addPointerEvent(this.win, \"pointermove\", this.onPointerMove),\n      addPointerEvent(this.win, \"pointerup\", this.onPointerUp),\n      addPointerEvent(this.win, \"pointercancel\", this.onPointerUp),\n    )\n  }\n\n  private updatePoint = () => {\n    if (!(this.lastEvent && this.lastEventInfo)) return\n\n    const info = getPanInfo(this.lastEventInfo, this.history)\n\n    const isPanStarted = this.startEvent !== null\n\n    const isDistancePastThreshold =\n      distance(info.offset, { x: 0, y: 0 }) >= this.threshold\n\n    if (!isPanStarted && !isDistancePastThreshold) return\n\n    const { timestamp } = getFrameData()\n    this.history.push({ ...info.point, timestamp })\n\n    const { onStart, onMove } = this.handlers\n\n    if (!isPanStarted) {\n      onStart?.(this.lastEvent, info)\n      this.startEvent = this.lastEvent\n    }\n\n    onMove?.(this.lastEvent, info)\n  }\n\n  private onPointerMove = (event: AnyPointerEvent, info: PointerEventInfo) => {\n    this.lastEvent = event\n    this.lastEventInfo = info\n\n    // Throttle mouse move event to once per frame\n    sync.update(this.updatePoint, true)\n  }\n\n  private onPointerUp = (event: AnyPointerEvent, info: PointerEventInfo) => {\n    // notify pan session ended\n    const panInfo = getPanInfo(info, this.history)\n    const { onEnd, onSessionEnd } = this.handlers\n\n    onSessionEnd?.(event, panInfo)\n    this.end()\n\n    // if panning never started, no need to call `onEnd`\n    // panning requires a pointermove of at least 3px\n    if (!onEnd || !this.startEvent) return\n\n    onEnd?.(event, panInfo)\n  }\n\n  updateHandlers(handlers: Partial<PanEventHandlers>) {\n    this.handlers = handlers\n  }\n\n  end() {\n    this.removeListeners?.()\n    cancelSync.update(this.updatePoint)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Utilities\n * -----------------------------------------------------------------------------*/\n\nfunction subtract(a: Point, b: Point) {\n  return { x: a.x - b.x, y: a.y - b.y }\n}\n\nfunction getPanInfo(info: PointerEventInfo, history: PanEventHistory) {\n  return {\n    point: info.point,\n    delta: subtract(info.point, history[history.length - 1]),\n    offset: subtract(info.point, history[0]),\n    velocity: getVelocity(history, 0.1),\n  }\n}\n\nconst toMilliseconds = (v: number) => v * 1000\n\nfunction getVelocity(history: TimestampedPoint[], timeDelta: number): Point {\n  if (history.length < 2) {\n    return { x: 0, y: 0 }\n  }\n\n  let i = history.length - 1\n  let timestampedPoint: TimestampedPoint | null = null\n  const lastPoint = history[history.length - 1]\n  while (i >= 0) {\n    timestampedPoint = history[i]\n    if (\n      lastPoint.timestamp - timestampedPoint.timestamp >\n      toMilliseconds(timeDelta)\n    ) {\n      break\n    }\n    i--\n  }\n\n  if (!timestampedPoint) {\n    return { x: 0, y: 0 }\n  }\n\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000\n  if (time === 0) {\n    return { x: 0, y: 0 }\n  }\n\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time,\n  }\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0\n  }\n\n  return currentVelocity\n}\n\nfunction pipe<R>(...fns: Array<(a: R) => R>) {\n  return (v: R) => fns.reduce((a, b) => b(a), v)\n}\n\nfunction distance1D(a: number, b: number) {\n  return Math.abs(a - b)\n}\n\nfunction isPoint(point: any): point is { x: number; y: number } {\n  return \"x\" in point && \"y\" in point\n}\n\nexport function distance<P extends Point | number>(a: P, b: P) {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return distance1D(a, b)\n  }\n\n  if (isPoint(a) && isPoint(b)) {\n    const xDelta = distance1D(a.x, b.x)\n    const yDelta = distance1D(a.y, b.y)\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2)\n  }\n\n  return 0\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}